<!DOCTYPE html>
<html>
<!--
  shaders_blinnphong.html
  Glenn G. Chappell
  23 Oct 2017

  For CS 381 Fall 2017
  Shader Example: Blinn-Phong Illumination Model

  Requires gl-matrix-min.js, quoll.js
-->

<!-- ************************************************************** -->
<!-- * Core HTML                                                  * -->
<!-- ************************************************************** -->

<head>
<meta charset="utf-8">
<title>Using Shaders</title>
</head>
<body onload="appMain('can1')"
  style="overflow: hidden; margin: 0; padding: 0;">

<canvas id="can1" width="500" height="400"
    style="display: block; margin: 0; padding: 0;"></canvas>
<script type="text/javascript" src="gl-matrix-min.js"></script>
<script type="text/javascript" src="quoll.js"></script>

<!-- ************************************************************** -->
<!-- * GLSL Shaders                                               * -->
<!-- ************************************************************** -->

<script id="vshader1" type="x-shader/x-vertex">
// Vertex Shader #1

uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;
uniform mat3 normalMatrix;

attribute vec4 vertex_attr;
attribute vec4 color_attr;
attribute vec3 normal_attr;

varying vec4 paintcolor_var;
varying vec3 surfpt_var;
varying vec3 surfnorm_var;

void main()
{
    // Compute vertex position
    vec4 surfpt4 = modelViewMatrix * vertex_attr;
    surfpt_var = surfpt4.xyz / surfpt4.w;
    gl_Position = projectionMatrix * surfpt4;

    // Compute normal
    surfnorm_var = normalize(normalMatrix * normal_attr);

    // Send paint color to fragment shader
    paintcolor_var = color_attr;
}
</script>
<script id="fshader1" type="x-shader/x-fragment">
// Fragment Shader #1

#ifdef GL_ES
precision mediump float;
#endif

varying vec4 paintcolor_var;
varying vec3 surfpt_var;
varying vec3 surfnorm_var;

// bpLight
// Compute color based on Blinn-Phong Illumination Model.
vec4 bpLight(
    vec4 lightcolor,
    vec4 lightpos4,  // Homogeneous form
    vec4 paintcolor,
    vec3 surfpt,
    vec3 surfnorm)
{
    // ***** Scalar Lighting Parameters *****

    float ambientfrac = 0.2;
        // Ambient light color, as fraction of light color
    float shininess = 50.;
        // PHONG Model shininess exponent
        // (Blinn-Phong needs 4 times larger)

    // ***** Direction of Light Source (cam coords) *****
    vec3 lightdir;
    if (lightpos4.w == 0.)
        lightdir = normalize(lightpos4.xyz);
    else
        lightdir = normalize(lightpos4.xyz/lightpos4.w - surfpt);

    // ***** Compute the Three Parts of Blinn-Phong Model *****

    // Ambient
    vec4 ambientcolor = ambientfrac * lightcolor * paintcolor;

    // Diffuse
    // Lambert cosine (or 0 if this is negative)
    float lambertcos = max(0., dot(surfnorm, lightdir));
    vec4 diffusecolor = lambertcos * lightcolor * paintcolor;

    // Specular
    vec3 viewdir = normalize(-surfpt);
    vec3 halfway = normalize(viewdir + lightdir);
    float specularcoeff = pow(max(0., dot(surfnorm, halfway)),
                              4.*shininess);
        // Blinn-Phong needs shininiess 4 * [Phong shininess]
    vec4 specularcolor = specularcoeff * lightcolor;

    // ***** Combine the Three Parts *****

    return clamp(ambientcolor + diffusecolor + specularcolor,
                 0., 1.);
}
void main()
{
    // Surface normal
    vec3 surfnorm = normalize(surfnorm_var);

    // Light-source color & position/direction
    vec4 lightcolor = vec4(1., 1., 1., 1.);  // White
    vec4 lightpos4 =  vec4(-1., 2., 2., 1.);

    // Apply Blinn-Phong Illumination Model
    vec4 litcolor = bpLight(
        lightcolor,
        lightpos4,
        paintcolor_var,
        surfpt_var,
        surfnorm);

    // Send color to framebuffer
    gl_FragColor = vec4(litcolor.rgb, 1.0);
}
</script>

<!-- END GLSL Shaders -->

<!-- ************************************************************** -->
<!-- * JavaScript Application                                     * -->
<!-- ************************************************************** -->

<script type="text/javascript">
// Global variables

// WebGL General
let gl;                 // WebGL rendering context

// Shaders
let shaderprog1;        // Shader program object

let cameraPos;
let farClipping;

// Ground
let ground;             // Stores the ground

// Colors
let BLACK = [0., 0., 0.];
let WHITE = [1., 1., 1.];

// Classes Definitions
class Ground {
  constructor() {
    this.colors = [BLACK, WHITE];
    
    this.numTiles = 60;
    this.tileSize = 0.5;
  }

  show() {
    pushMvMatrix(gl);
    
    mat4.rotate(gl.mvMatrix, gl.mvMatrix,
        -Math.PI / 3., [1.,0.,0.]);

    //mat4.translate(gl.mvMatrix, gl.mvMatrix,
        //[-5, -1., -5.]);

    let gap = this.tileSize; 

    for (let r = 0; r < this.numTiles; ++r) {
      for (let c = 0; c < this.numTiles; ++c) {

        mat4.translate(gl.mvMatrix, gl.mvMatrix,
           [gap, 0.0 , 0.]);
        drawSquare(gl, this.tileSize, this.colors[0][1], this.colors[0][2], this.colors[0][2], 1.);
        
      }
      //mat4.translate(gl.mvMatrix, gl.mvMatrix,
       //   [gap, 0.0 , 0.]);
    }


    popMvMatrix(gl);
  }
}

// appMain
// Our Main program.
// Given ID of canvas.
function appMain(canvasid)
{
    // Initialize quoll.js & WebGL
    gl = quollInit(canvasid);
    if (!gl) return;  // Could not intialize; exit

    // Shaders
    shaderprog1 = makeProgramObjectFromIds(gl, 'vshader1', 'fshader1');
    farClipping = 30.; 
    cameraPos = [0., 0., -4.];

    // Register callbacks with quoll.js
    registerDisplay(myDisplay);
    registerIdle(myIdle);
    registerReshape(myReshape);
    canvasFullWindow(true);  // Make canvas fill the window

    // Set up other event handlers
    document.addEventListener('keypress', myKeyboard, false);
    
    ground = new Ground();

    // GL States
    gl.enable(gl.DEPTH_TEST);
}


// myDisplay
// The display function.
function myDisplay()
{
    gl.useProgram(shaderprog1);

    // Camera transformation
    mat4.identity(gl.mvMatrix);
    mat4.translate(gl.mvMatrix, gl.mvMatrix,
        cameraPos);

    // Place and draw object
    mat4.translate(gl.mvMatrix, gl.mvMatrix,
        [0., 0., 0.]);
    mat4.rotate(gl.mvMatrix, gl.mvMatrix,
        0, [1.,2.,0.]);

    ground.show(); 

    gl.flush();
}


// myIdle
// The idle function.
function myIdle()
{
    let elapsedtime = getElapsedTime(0.1);

    
}


// myReshape
// The reshape callback function. Called by quoll.js.
function myReshape(w, h)
{
    // Set up viewport
    gl.viewport(0, 0, w, h);

    // Set up projection
    mat4.perspective(gl.pMatrix,
                     Math.PI/180. * 60.,  // y field-of-view angle
                     w/h,                 // Viewport aspect ratio
                     0.1, farClipping);           // Near & far distances
}


function myKeyboard(evt)
{
    let ch = keyFromEvent(evt);


}
</script>
</body>
</html>

